<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="../base.css">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sound Safari Game</title>
  <!-- Google Fonts: Quicksand for a phonics-friendly, single-storey 'a' and clear 'l' -->
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f0f8ff;
      --primary-color: #333;
      --secondary-color: #555;
      --button-bg: #fff0d5;
      --button-hover-bg: #ffe4b5;
      --button-selected-bg: #b6d7a8;
      --correct-bg: #93c47d;
      --correct-hover-bg: #6aa84f;
      --incorrect-bg: #e06666; /* Added for general incorrect feedback */
      --border-color: #ccc;
      --border-width: 3px;
      --border-radius: 15px;
      --main-font: 'Quicksand', sans-serif; /* Updated to Quicksand */
      --canvas-border: #a8dadc;
      --canvas-drawing-color: #457b9d;
    }

    body {
      font-family: var(--main-font);
      background-color: var(--bg-color);
      color: var(--primary-color);
      text-align: center;
      padding: 30px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    h1 {
      font-size: clamp(2em, 8vw, 3em);
      margin-bottom: 20px;
    }
    
    button {
      font-family: inherit;
      border: none;
      background: none;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      -webkit-tap-highlight-color: transparent;
    }

    button:active {
        transform: scale(0.95);
    }

    button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .home-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background-color: var(--home-button-bg);
        color: var(--primary-color);
        font-size: clamp(1em, 3vw, 1.2em);
        padding: 10px 20px;
        border-radius: var(--border-radius);
        border: 2px solid var(--border-color);
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }

    .home-button:hover {
        background-color: var(--home-button-hover-bg);
    }

    .menu-button {
      background: var(--button-bg);
      border: var(--border-width) solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 20px;
      margin: 15px;
      font-size: clamp(1em, 4vw, 1.5em);
      box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
    }

    .menu-button:hover {
      background: var(--button-hover-bg);
    }
    
    /* Removed specific background-color for #buildWordBtn to match others */
    /* #buildWordBtn {
        background-color: var(--build-button-bg);
    }
    #buildWordBtn:hover {
        background-color: var(--build-button-hover-bg);
    } */

    /* Style for Flashcard Pack Selection buttons */
    #flashcardPackSelection .menu-button {
        background-color: var(--button-bg);
        border: var(--border-width) solid var(--border-color);
        margin: 10px;
        padding: 15px;
        font-size: clamp(1em, 3.5vw, 1.3em);
    }
    #flashcardPackSelection .menu-button:hover {
        background-color: var(--button-hover-bg);
    }


    /* Re-added score and stars display */
    .score {
      font-size: 1.5em;
      margin-bottom: 10px;
    }

    .stars {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
      height: 2em;
    }

    .star {
      font-size: 2em;
      margin: 0 5px;
    }
    

    #prompt {
      font-size: clamp(1em, 4vw, 1.3em); /* Made smaller */
      margin-bottom: 20px;
      min-height: 1.2em;
    }

    .blend-box {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      max-width: 900px;
      width: 100%;
    }
    
    .blend-box.horizontal {
        flex-direction: row;
    }

    /* Styles for flashcard in Learn Mode */
    #flashcardContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 300px;
        min-height: 200px; /* Maintain height to prevent jumping */
        margin: 20px auto;
        background-color: var(--button-bg);
        border: var(--border-width) solid var(--border-color);
        border-radius: var(--border-radius);
        box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
        opacity: 1; /* Default state */
        transition: opacity 0.3s ease-in-out; /* Smooth transition for opacity */
        padding-bottom: 10px; /* Add padding for description */
    }

    #flashcardContainer.fade-out {
        opacity: 0;
    }

    #flashcardLetter {
        font-size: clamp(4em, 15vw, 8em);
        font-weight: bold;
        color: var(--primary-color);
        margin: 0;
        padding: 20px;
        transition: color 0.3s ease-in-out; /* Smooth color transition for reveal */
    }
    
    #flashcardLetter.hidden-content { /* Renamed for clarity */
        color: transparent; /* Hide the letter but keep its space */
    }

    #flashcardPhonemeDescription {
        font-size: clamp(0.9em, 2.5vw, 1.1em);
        color: var(--secondary-color);
        margin-top: -10px; /* Pull it slightly closer to the letter */
        margin-bottom: 10px;
        min-height: 1.2em; /* Prevent layout shift if no text */
        text-align: center;
        padding: 0 10px;
    }


    .flashcard-nav-buttons {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-top: 15px;
        padding: 0 10px;
    }

    .flashcard-nav-buttons button {
        background-color: var(--home-button-bg);
        padding: 10px 20px;
        border-radius: var(--border-radius);
        border: 2px solid var(--border-color);
        font-size: 1.2em;
        min-width: 100px;
    }
    .flashcard-nav-buttons button:hover {
        background-color: var(--home-button-hover-bg);
    }
    
    /* Buttons for flashcard self-assessment */
    .flashcard-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
    }
    .flashcard-actions button {
        background-color: var(--correct-bg);
        color: white;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        font-size: 1.1em;
        min-width: 120px;
        box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    .flashcard-actions button:hover {
        opacity: 0.9;
    }

    #flashcardProgress {
        margin-top: 10px;
        font-size: 1em;
        color: var(--secondary-color);
    }

    /* Hide individual letter set containers in flashcard mode */
    .letter-set-container {
        display: none; 
    }

    .letter-set-title {
      font-size: clamp(1.2em, 4vw, 1.5em);
      color: var(--secondary-color);
      margin-bottom: 15px;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .letters-wrapper {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }

    .letter {
      background: var(--button-bg);
      border: var(--border-width) solid var(--border-color);
      border-radius: var(--border-radius);
      width: clamp(70px, 18vw, 90px); /* Made larger */
      height: clamp(70px, 18vw, 90px); /* Made larger */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(3em, 10vw, 4em); /* Increased font size */
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
      transition: background-color 0.2s ease-in-out; /* For click feedback */
    }
    
    .letter.selected {
      background-color: var(--button-selected-bg);
      border-color: #79ac65;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3);
    }
    
    /* New styles for letter click feedback */
    .letter.blended-active {
        background-color: var(--home-button-hover-bg); /* Highlight color on click */
        transform: scale(1.05); /* Slightly pop out */
        transition: all 0.1s ease-out;
    }

    .letter:hover,
    .word-choice:hover {
      background: var(--button-hover-bg);
    }

    .blended-word {
      font-size: clamp(4em, 14vw, 6em); /* Increased font size */
      font-weight: bold;
      margin: 20px 0;
      color: var(--primary-color);
      min-height: 1.5em;
    }

    .choices {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      max-width: 900px;
      width: 100%;
    }

    .word-choice {
      background: var(--button-bg);
      border: var(--border-width) solid var(--border-color);
      border-radius: var(--border-radius);
      padding: clamp(15px, 5vw, 30px);
      font-size: clamp(1.5em, 5vw, 2em);
      flex: 1 1 30%;
      min-width: 150px;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
      transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out; /* For feedback colors */
    }

    /* New styles for word choice feedback */
    .word-choice.correct-feedback {
        background-color: var(--correct-bg);
        border-color: #6aa84f;
        color: white;
    }

    .word-choice.incorrect-feedback {
        background-color: var(--incorrect-bg); 
        border-color: #a63f3f;
        color: white;
    }

    .reset-button {
      background: var(--button-bg);
      border: var(--border-width) solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 15px 25px;
      font-size: clamp(1em, 4vw, 1.5em);
      margin-bottom: 20px; /* Keep existing margin */
      /* margin-top: 40px; /* Removed this specific margin-top */
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }

    .reset-button:hover {
      background: var(--button-hover-bg);
    }

    .feedback {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-top: 30px;
      font-weight: bold;
      min-height: 1.5em;
    }

    .emoji {
      font-size: 1.5em;
      margin-left: 0.2em;
    }

    .play-again {
      background: var(--correct-bg);
      color: white;
      border-radius: var(--border-radius);
      padding: 20px 30px;
      font-size: clamp(1em, 4vw, 1.2em);
      margin-top: 30px;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
    }

    .play-again:hover {
      background: var(--correct-hover-bg);
    }
    
    .hidden {
        display: none !important;
    }

    /* Styles for Build a Word mode */
    #buildWordDisplay {
        font-size: clamp(2.5em, 10vw, 4em);
        font-weight: bold;
        color: var(--primary-color);
        display: flex;
        justify-content: center;
        gap: 10px; /* Increased gap between letters in built word */
        border-bottom: 2px solid var(--secondary-color);
        padding-bottom: 10px;
        margin: 20px 0 30px 0; /* Combined margin properties */
        min-height: 1.5em;
        transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out; /* For feedback colors */
    }
    /* New style for incorrect feedback on buildWordDisplay */
    #buildWordDisplay.incorrect-feedback {
        background-color: var(--incorrect-bg); 
        border-color: #a63f3f;
        color: white;
    }


    /* New styles for the build word target flashcard */
    #buildWordTargetFlashcard {
        display: flex;
        flex-direction: column; /* Allow text description below word */
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 300px;
        min-height: 100px; /* Adjusted height for words */
        margin: 15px auto;
        background-color: var(--button-bg);
        border: var(--border-width) solid var(--border-color);
        border-radius: var(--border-radius);
        box-shadow: 3px 33px 8px rgba(0,0,0,0.2);
        font-size: clamp(2.5em, 8vw, 4em); /* Size for target word */
        font-weight: bold;
        color: var(--primary-color);
        opacity: 0; /* Start hidden for fade-in */
        transition: opacity 0.5s ease-in-out;
    }
    #buildWordTargetFlashcard.fade-in {
        opacity: 1;
    }


    #letterPool {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
    }

    #letterPool .letter { /* Re-use existing .letter style for pool */
        background-color: var(--build-button-bg);
    }
    #letterPool .letter:hover {
        background-color: var(--build-button-hover-bg);
    }
    #letterPool .letter.selected { /* This class is now used for letters moved to userBuiltWord */
        background-color: var(--button-selected-bg);
        border-color: #79ac65;
    }

    .build-actions {
        margin-top: 30px;
        display: flex;
        gap: 20px;
        justify-content: center;
        flex-wrap: wrap;
    }
    .build-actions button {
        background-color: var(--home-button-bg);
        padding: 15px 30px;
        border-radius: var(--border-radius);
        border: 2px solid var(--border-color);
        font-size: 1.2em;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    .build-actions button:hover {
        background-color: var(--home-button-hover-bg);
    }

    /* Styles for the new Picture-Word Matching mode */
    #pictureWordMatchingSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 600px;
        margin-top: 20px;
    }

    #pictureWordImage {
        width: clamp(180px, 45vw, 300px);
        height: clamp(180px, 45vw, 300px);
        object-fit: contain;
        margin-bottom: 25px;
        border-radius: 15px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    #pictureWordChoices {
        display: grid; /* Changed to grid */
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* Responsive grid, min width 140px, fills space */
        justify-items: center; /* Center items within their grid cells */
        gap: 15px;
        width: 100%;
    }

    #pictureWordChoices .word-choice {
        width: 100%; /* Make it fill its grid cell */
        max-width: 200px; /* Optional: cap max width for very large screens */
        padding: clamp(15px, 4vw, 25px);
        font-size: clamp(1.3em, 4.5vw, 1.8em);
    }

    /* Styles for the new Tricky Word Sorting Game */
    #trickyWordSortingSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 900px;
        margin-top: 20px;
    }

    .sort-zones-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        width: 100%;
        margin-bottom: 0; /* Reduced to 0 */
    }

    .sort-zone {
        flex: 1 1 45%; /* Two columns */
        min-width: 280px;
        border: 3px dashed var(--border-color); /* Changed to solid for clarity */
        border-radius: var(--border-radius);
        padding: 20px;
        min-height: 200px;
        display: flex;
        flex-direction: column; /* Keep column for h3 and words-container */
        align-items: center;
        background-color: #f8f8f8;
        transition: background-color 0.2s, border-color 0.2s;
    }

    .sort-zone .words-container { /* New style for inner container */
        display: flex;
        flex-wrap: wrap;
        justify-content: center; /* Center words horizontally */
        align-items: flex-start; /* Align words to the top of the container */
        width: 100%; /* Take full width of parent sort-zone */
        min-height: 150px; /* Give it some height to drop into */
        padding: 10px; /* Some padding inside */
        box-sizing: border-box; /* Include padding in width */
    }

    .sort-zone.drag-over {
        border-color: var(--drop-zone-active-border);
        background-color: #e0f2f7;
    }

    .sort-zone h3 {
        font-size: clamp(1.5em, 5vw, 2em);
        margin-bottom: 15px;
        color: var(--secondary-color);
    }

    .sortable-word {
        background: var(--button-bg);
        border: var(--border-width) solid var(--border-color);
        border-radius: 10px;
        padding: 10px 20px;
        margin: 8px;
        font-size: clamp(1.2em, 4vw, 1.5em);
        font-weight: bold;
        cursor: grab;
        box-shadow: 1px 2px 3px rgba(0,0,0,0.15);
        transition: transform 0.1s, box-shadow 0.1s, background-color 0.2s;
        user-select: none;
    }

    .sortable-word:hover {
        background-color: var(--button-hover-bg);
    }

    .sortable-word:active {
        cursor: grabbing;
        transform: scale(1.05);
        box-shadow: 2px 3px 5px rgba(0,0,0,0.2);
    }

    .word-pool-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin-bottom: 0; /* Reduced to 0 */
        border: 2px solid var(--border-color);
        border-radius: var(--border-radius);
        padding: 15px;
        background-color: #e6f7ff; /* Light blue background for pool */
    }

    .sort-feedback {
        font-size: clamp(1.2em, 4vw, 1.6em);
        margin: 2px 0; /* Set margin to 2px top/bottom */
        min-height: 0; /* Allow it to collapse when empty */
        font-weight: bold;
    }

    #trickySortFeedback:empty {
        display: none; /* Hide when empty */
    }

    .sort-feedback.correct {
        color: var(--correct-bg);
    }

    .sort-feedback.incorrect {
        color: var(--incorrect-bg);
    }

    /* New style for action buttons (e.g., Check, Next) */
    .action-buttons {
        background-color: var(--correct-bg); /* Use a distinct color */
        color: white; /* Ensure text is visible */
        border: var(--border-width) solid var(--correct-hover-bg); /* Solid border */
        border-radius: var(--border-radius);
        padding: 15px 30px;
        font-size: clamp(1em, 4vw, 1.5em);
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        /* Removed individual margin-top to be controlled by parent .sort-actions */
        display: inline-block; /* Explicitly set display */
        min-width: 180px; /* Added for guaranteed width */
    }

    .action-buttons:hover {
        background-color: var(--correct-hover-bg);
    }

    /* New container for sort buttons */
    .sort-actions {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 0; /* Reduced to 0 */
        flex-wrap: wrap;
    }

    /* Styles for Canvas Drawing Tracer */
    #canvasDrawingTracerSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: min(90vw, 400px);
        aspect-ratio: 1 / 1; 
        border-radius: 15px;
        padding: 0;
        box-sizing: border-box; 
        margin: 20px auto;
    }

    #letterCanvas {
        background-color: #ffffff;
        border: 3px solid var(--canvas-border);
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        touch-action: none;
        width: 100%;
        height: 100%;
        display: block;
    }

    .canvas-actions {
        display: flex;
        gap: 15px;
        margin-top: 20px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .canvas-actions button {
        background-color: var(--home-button-bg);
        color: var(--primary-color);
        padding: 12px 25px;
        border-radius: var(--border-radius);
        border: 2px solid var(--border-color);
        font-size: clamp(1em, 3.5vw, 1.2em);
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    .canvas-actions button:hover {
        background-color: var(--home-button-hover-bg);
    }

  </style>
</head>
<body>
  <div class="app-container">
  <button id="homeBtn" class="home-button hidden">üè† Home</button>

  <h1>ü¶Å Sound Safari</h1>
  <div id="menu">
    <button class="menu-button" id="learnLettersBtn">üß© Practice Phase 2 Sounds</button>
    <button class="menu-button" id="blendWordsBtn">üî§ Blend SATPIN Words</button>
    <button class="menu-button" id="buildWordBtn">üõ†Ô∏è Build a Word</button>
    <button class="menu-button" id="trickyWordsBtn">ü§Ø Tricky Words</button>
    <button class="menu-button" id="pictureWordMatchBtn">üñºÔ∏è Picture-Word Match</button> <button class="menu-button" id="trickyWordSortBtn">üß† Tricky Word Sort</button> <button class="menu-button" id="canvasDrawingTracerBtn">‚úçÔ∏è Trace Letters</button> </div>

  <div id="gameArea" class="hidden">
    <!-- Re-added score and stars display -->
    <div class="score" id="score">Score: 0</div>
    <div class="stars" id="stars"></div>
    <h2 id="prompt"></h2>

    <div id="flashcardPackSelection" class="hidden">
      <p id="packSelectionIntroText">Choose a Set:</p>
      <div id="packButtons" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px;">
        </div>
      <button class="menu-button" id="backToMainMenuBtn">Back to Main Menu</button>
    </div>

    <div id="flashcardContainer" class="hidden" data-mastered-unique-letters="">
        <p id="flashcardLetter"></p>
        <p id="flashcardPhonemeDescription"></p>
        <div id="flashcardActions" class="flashcard-actions">
            <button id="gotItBtn">‚úÖ Got It!</button>
            <button id="needPracticeBtn" class="need-practice">‚ùå Need Practice</button>
        </div>
        <div class="flashcard-nav-buttons hidden">
            </div>
        <div id="flashcardProgress"></div>
    </div>

    <div class="blend-box" id="blendBox"></div>
    <div class="blended-word" id="blendText"></div>

    <div id="buildWordTargetFlashcard" class="hidden"></div>

    <div id="buildWordDisplay" class="hidden"></div>
    <div id="letterPool" class="hidden"></div>
    <div class="build-actions hidden">
        <button id="clearBuildBtn">Clear</button>
        <button id="deleteBuildBtn">‚¨ÖÔ∏è Delete</button>
        <button id="checkBuildBtn">Check</button>
    </div>

    <div id="pictureWordMatchingSection" class="hidden"> <img id="pictureWordImage" src="" alt="Image to match" class="hidden" onerror="this.onerror=null; this.src='https://via.placeholder.com/150x150/FF0000/FFFFFF?text=Error'; console.error('Image failed to load:', this.src);">
        <div id="pictureWordChoices"></div>
        <button class="reset-button" id="pictureWordResetBtn">üîÑ Reset Choices</button>
    </div>

    <div id="trickyWordSortingSection" class="hidden"> <div class="sort-zones-container">
            <div id="trickyZone" class="sort-zone">
                <h3>Tricky Words ü§Ø</h3>
                <div class="words-container"></div>
            </div>
            <div id="notTrickyZone" class="sort-zone">
                <h3>Not Tricky Words ‚úÖ</h3>
                <div class="words-container"></div>
            </div>
        </div>
        <div id="trickyWordPool" class="word-pool-container"></div>
        <p id="trickySortFeedback" class="sort-feedback"></p>
        <div class="sort-actions">
            <button class="action-buttons" id="trickySortResetBtn">üîÑ Reset Sort</button>
            <button class="action-buttons" id="trickySortCheckBtn">Check My Sort</button>
            <button class="action-buttons" id="newTrickySortResetBtn">Reset Game</button>
        </div>
    </div>

    <div id="canvasDrawingTracerSection" class="hidden"> <canvas id="letterCanvas"></canvas>
        <div class="canvas-actions">
            <button id="clearCanvasBtn">üóëÔ∏è Clear Drawing</button>
            <button id="nextLetterBtn">‚û°Ô∏è Next Letter</button>
        </div>
    </div>


    <div class="choices" id="wordChoices"></div>
    <button class="reset-button" id="resetBtn">üîÑ Reset</button>
    <div class="feedback" id="feedback"></div>
  </div>

  <div id="gameComplete" class="hidden">
    <h2>üèÜ Well done!</h2>
    <p id="finalMessage"></p>
    <button class="play-again" id="playAgainBtn">Play Again</button>
  </div>

  <script>
    console.log("Script execution started."); // Debugging log

    // Global variable to hold the element being dragged in Tricky Word Sort mode
    let draggedTrickyWordElement = null;

    // --- GLOBAL GAME DATA & STATE ---
    // These are declared globally so that functions outside DOMContentLoaded can access them.
    const letterSets = {
      'Set 1': ['s', 'a', 't', 'p'],
      'Set 2': ['i', 'n', 'm', 'd'],
      'Set 3': ['g', 'o', 'c', 'k'],
      'Set 4': ['ck', 'e', 'u', 'r'],
      'Set 5': ['h', 'b', 'f', 'ff', 'l', 'll', 'ss']
    };
    const allPhase2Letters = Object.values(letterSets).flat();
    const masterBuildLettersPool = [...letterSets['Set 1'], ...letterSets['Set 2']]; // For build a word

    const trickyWordSets = {
        'Set 1 ‚Äì Foundation Words': {
            words: ['I', 'the', 'to', 'no', 'go'],
            description: 'Short, very frequent words that appear in almost every beginner book.'
        },
        'Set 2 ‚Äì Early Sentence Builders': {
            words: ['into', 'he', 'she', 'we', 'me'],
            description: 'Helps children build simple subject-verb sentences like ‚ÄúHe is big.‚Äù'
        },
        'Set 3 ‚Äì Identity and Action Words': {
            words: ['be', 'was', 'my', 'you', 'they'],
            description: 'Introduces trickier spelling patterns and supports early storytelling.'
        },
        'Set 4 ‚Äì Describing and Referring Words': {
            words: ['her', 'all', 'are', 'your', 'said'],
            description: 'Introduces trickier spelling patterns and supports early storytelling.'
        }
    };

    const phonemeDetails = {
      's': {
        description: 'Snake sound: teeth close, tongue behind.',
        examples: [{ word: 'sun', emoji: '‚òÄÔ∏è' }, { word: 'sit', emoji: 'ü™ë' }],
        image: 'https://via.placeholder.com/150x150/87CEEB/FFFFFF?text=SNAKE'
      },
      'a': {
        description: 'Open mouth, "ah" sound like in apple.',
        examples: [{ word: 'apple', emoji: 'üçé' }, { word: 'ant', emoji: 'üêú' }],
        image: 'https://via.placeholder.com/150x150/FF6347/FFFFFF?text=APPLE'
      },
      't': {
        description: 'Tap tongue behind teeth, quick "tuh" sound.',
        examples: [{ word: 'top', emoji: '‚¨ÜÔ∏è' }, { word: 'ten', emoji: 'üîü' }],
        image: 'https://via.placeholder.com/150x150/FFD700/000000?text=TIGER'
      },
      'p': {
        description: 'Pop lips together, quick "puh" sound.',
        examples: [{ word: 'pen', emoji: 'üñäÔ∏è' }, { word: 'pig', emoji: 'üê∑' }],
        image: 'https://via.placeholder.com/150x150/98FB98/000000?text=PIG'
      },
      'i': {
        description: 'Small smile, "ih" sound like in ink.',
        examples: [{ word: 'ink', emoji: '‚úíÔ∏è' }, { word: 'igloo', emoji: 'üßä' }],
        image: 'https://via.placeholder.com/150x150/ADD8E6/000000?text=IGLOO'
      },
      'n': {
        description: 'Tongue tip behind teeth, nose hums.',
        examples: [{ word: 'net', emoji: 'üï∏Ô∏è' }, { word: 'nut', emoji: 'üå∞' }],
        image: 'https://via.placeholder.com/150x150/DDA0DD/000000?text=NEST'
      },
      'm': {
        description: 'Lips together, mouth closed, hum.',
        examples: [{ word: 'mat', emoji: 'üßò' }, { word: 'moon', emoji: 'üåï' }],
        image: 'https://via.placeholder.com/150x150/FFB6C1/000000?text=MOON'
      },
      'd': {
        description: 'Tap tongue behind teeth, quick "duh" sound.',
        examples: [{ word: 'dog', emoji: 'üê∂' }, { word: 'doll', emoji: 'üéé' }],
        image: 'https://via.placeholder.com/150x150/8FBC8F/000000?text=DOG'
      },
      'g': {
        description: 'Back of tongue up, "guh" sound.',
        examples: [{ word: 'go', emoji: '‚û°Ô∏è' }, { word: 'gap', emoji: '„Ä∞Ô∏è' }],
        image: 'https://via.placeholder.com/150x150/B0E0E6/000000?text=GOAT'
      },
      'o': {
        description: 'Round mouth, short "oh" sound.',
        examples: [{ word: 'on', emoji: 'üîõ' }, { word: 'pot', emoji: 'üç≤' }],
        image: 'https://via.placeholder.com/150x150/FFDAB9/000000?text=ORANGE'
      },
      'c': {
        description: 'Back of tongue up, quick "kuh" sound.',
        examples: [{ word: 'cat', emoji: 'üê±' }, { word: 'cup', emoji: '‚òï' }],
        image: 'https://via.placeholder.com/150x150/DDA0DD/000000?text=CAT'
      },
      'k': {
        description: 'Back of tongue up, quick "kuh" sound.',
        examples: [{ word: 'kid', emoji: 'üßí' }, { word: 'kit', emoji: 'üõ†Ô∏è' }],
        image: 'https://via.placeholder.com/150x150/FFDEAD/000000?text=KITE'
      },
      'ck': {
        description: 'Same as "k", two letters one sound.',
        examples: [{ word: 'duck', emoji: 'ü¶Ü' }, { word: 'sock', emoji: 'üß¶' }],
        image: 'https://via.placeholder.com/150x150/F0E68C/000000?text=DUCK'
      },
      'e': {
        description: 'Relaxed mouth, short "eh" sound.',
        examples: [{ word: 'egg', emoji: 'ü•ö' }, { word: 'red', emoji: 'üî¥' }],
        image: 'https://via.placeholder.com/150x150/F4A460/000000?text=EGG'
      },
      'u': {
        description: 'Short "uh" sound, like up.',
        examples: [{ word: 'up', emoji: '‚¨ÜÔ∏è' }, { word: 'cup', emoji: '‚òï' }],
        image: 'https://via.placeholder.com/150x150/D8BFD8/000000?text=UMBRELLA'
      },
      'r': {
        description: 'Tongue curls back, "rrr" sound.',
        examples: [{ word: 'run', emoji: 'üèÉ' }, { word: 'rat', emoji: 'üêÄ' }],
        image: 'https://via.placeholder.com/150x150/C0C0C0/000000?text=RABBIT'
      },
      'h': {
        description: 'Quiet breath out of mouth.',
        examples: [{ word: 'hat', emoji: 'üé©' }, { word: 'hen', emoji: 'üêî' }],
        image: 'https://via.placeholder.com/150x150/FFDAB9/000000?text=HAT'
      },
      'b': {
        description: 'Lips together, puff of air, "buh" sound.',
        examples: [{ word: 'bat', emoji: 'üèè' }, { word: 'bus', emoji: 'üöå' }],
        image: 'https://via.placeholder.com/150x150/A2CD5A/000000?text=BALL'
      },
      'f': {
        description: 'Top teeth on lower lip, blow air.',
        examples: [{ word: 'fan', emoji: 'üå¨Ô∏è' }, { word: 'fish', emoji: 'üê†' }],
        image: 'https://via.placeholder.com/150x150/87CEFA/000000?text=FISH'
      },
      'ff': {
        description: 'Same as "f", two letters one sound.',
        examples: [{ word: 'puff', emoji: 'üí®' }, { word: 'off', emoji: '‚ùå' }],
        image: 'https://via.placeholder.com/150x150/87CEFA/000000?text=FISH' // Same image as 'f'
      },
      'l': {
        description: 'Tongue tip behind top teeth, "llll" sound.',
        examples: [{ word: 'leg', emoji: 'ü¶µ' }, { word: 'lip', emoji: 'üëÑ' }],
        image: 'https://via.placeholder.com/150x150/F08080/000000?text=LEAF'
      },
      'll': {
        description: 'Same as "l", two letters one sound.',
        examples: [{ word: 'bell', emoji: 'üîî' }, { word: 'fill', emoji: 'üíß' }],
        image: 'https://via.placeholder.com/150x150/F08080/000000?text=LEAF' // Same image as 'l'
      },
      'ss': {
        description: 'Same as "s", two letters one sound.',
        examples: [{ word: 'hiss', emoji: 'üêç' }, { word: 'mess', emoji: ' messy' }],
        image: 'https://via.placeholder.com/150x150/87CEEB/FFFFFF?text=SNAKE' // Same image as 's'
      }
    };

    const satpinWordsList = [
      { word: 'sat', emoji: 'ü™ë', image: 'https://via.placeholder.com/250x250/FFDAB9/000000?text=SAT' }, // Changed to via.placeholder.com
      { word: 'pin', emoji: 'üìå', image: 'https://via.placeholder.com/250x250/ADD8E6/000000?text=PIN' },
      { word: 'pat', emoji: 'üëè', image: 'https://via.placeholder.com/250x250/98FB98/000000?text=PAT' },
      { word: 'tap', emoji: 'üö∞', image: 'https://via.placeholder.com/250x250/FFD700/000000?text=TAP' },
      { word: 'nap', emoji: 'üò¥', image: 'https://via.placeholder.com/250x250/DDA0DD/000000?text=NAP' },
      { word: 'sip', emoji: 'ü•§', image: 'https://via.placeholder.com/250x250/87CEFA/000000?text=SIP' },
      { word: 'tip', emoji: 'üí°', image: 'https://via.placeholder.com/250x250/F08080/000000?text=TIP' },
      { word: 'tan', emoji: 'üåû', image: 'https://via.placeholder.com/250x250/F4A460/000000?text=TAN' },
      { word: 'pit', emoji: 'üï≥Ô∏è', image: 'https://via.placeholder.com/250x250/B0E0E6/000000?text=PIT' },
      { word: 'pan', emoji: 'üç≥', image: 'https://via.placeholder.com/250x250/FFB6C1/000000?text=PAN' }
    ];

    const trickyWordsData = {
        tricky: ['the', 'to', 'no', 'go', 'I', 'into', 'he', 'she', 'we', 'me', 'be', 'was', 'my', 'you', 'they', 'her', 'all', 'are', 'your', 'said'],
        notTricky: ['cat', 'dog', 'sun', 'cup', 'bed', 'fan', 'hat', 'pig', 'box', 'fox']
    };

    let elements = {}; // Declare elements globally
    let gameState = { // Declare gameState globally
      score: 0, // Re-added
      stars: 0, // Re-added
      blended: '',
      correctWord: '',
      correctEmoji: '',
      currentWords: [], 
      mode: '', 

      currentFlashcardIndex: 0, 
      currentFlashcardLetters: [], 
      currentFlashcardSetName: '', 
      flashcardMasterList: [],
      flashcardsCompletedCount: 0,
      packSelectionType: '', 
      currentFlashcardSetDescription: '', 
      
      targetBuildWord: '',
      userBuiltWord: [], 
      usedLetterButtons: [], 
      availableBuildWords: [], 

      pictureWordMatchWords: [],
      currentPictureWord: null,

      trickySortWords: [],
      
      currentTracingLetter: '',
      isDrawing: false,
      lastX: 0,
      lastY: 0,
      hasDrawnOnCanvas: false,
      canvasCtx: null,
      lettersToTrace: [],
    };

    // --- UTILITY FUNCTIONS (GLOBAL) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function toggleBlendingControls(enable) {
        const letterButtons = elements.blendBox.querySelectorAll('.letter');
        letterButtons.forEach(button => {
            button.disabled = !enable;
        });
        const wordChoiceButtons = elements.wordChoices.querySelectorAll('.word-choice');
        wordChoiceButtons.forEach(button => {
            button.disabled = !enable;
        });
    }

    function updateBuildWordDisplay() {
        elements.buildWordDisplay.textContent = gameState.userBuiltWord.join('');
        elements.feedback.textContent = ''; 
    }

    // Re-added updateScore and updateStars functions
    function updateScore() {
      if (['words', 'pictureWordMatch', 'trickyWordSort', 'canvasDrawingTracer', 'build'].includes(gameState.mode)) { 
          elements.scoreDisplay.textContent = `Score: ${gameState.score}`;
          elements.scoreDisplay.classList.remove('hidden');
      } else {
          elements.scoreDisplay.classList.add('hidden'); 
      }
    }

    function updateStars() {
      elements.starsDisplay.innerHTML = Array(gameState.stars).fill('‚≠ê').map(s => `<span class="star">${s}</span>`).join('');
      elements.starsDisplay.classList.remove('hidden');
    }
    
    function hideAllGameSpecificElements() {
        elements.flashcardPackSelection.classList.add('hidden');
        elements.flashcardContainer.classList.add('hidden');
        elements.flashcardActions.classList.add('hidden');
        elements.flashcardProgress.classList.add('hidden');
        elements.flashcardPhonemeDescription.textContent = ''; 


        elements.blendBox.innerHTML = '';
        elements.blendBox.classList.remove('horizontal');
        elements.blendText.textContent = '';
        elements.blendText.classList.add('hidden');

        elements.buildWordTargetFlashcard.classList.add('hidden'); 
        elements.buildWordTargetFlashcard.classList.remove('fade-in'); 
        elements.buildWordTargetFlashcard.textContent = '';


        elements.buildWordDisplay.innerHTML = '';
        elements.buildWordDisplay.classList.add('hidden');
        elements.buildWordDisplay.classList.remove('incorrect-feedback'); 
        elements.letterPool.innerHTML = '';
        elements.letterPool.classList.add('hidden');
        elements.clearBuildBtn.classList.add('hidden');
        elements.deleteBuildBtn.classList.add('hidden'); 
        elements.checkBuildBtn.classList.add('hidden');
        elements.buildActionsContainer.classList.add('hidden'); 
        elements.wordChoices.classList.add('hidden');
        elements.resetBtn.classList.add('hidden');

        // Hide Picture-Word Matching elements
        elements.pictureWordMatchingSection.classList.add('hidden');
        elements.pictureWordImage.classList.add('hidden');
        elements.pictureWordImage.src = '';
        elements.pictureWordChoices.innerHTML = '';
        elements.pictureWordResetBtn.classList.add('hidden');

        // Hide Tricky Word Sorting elements
        elements.trickyWordSortingSection.classList.add('hidden');
        // Ensure words-container is cleared and re-added correctly
        elements.trickyZone.innerHTML = '<h3>Tricky Words ü§Ø</h3><div class="words-container"></div>'; 
        elements.notTrickyZone.innerHTML = '<h3>Not Tricky Words ‚úÖ</h3><div class="words-container"></div>'; 
        elements.trickyWordPool.innerHTML = '';
        elements.trickySortFeedback.textContent = '';
        elements.trickySortResetBtn.classList.add('hidden');
        elements.trickySortCheckBtn.classList.add('hidden');
        elements.newTrickySortResetBtn.classList.add('hidden'); // Hide new reset button

        // Hide Canvas Drawing Tracer elements
        elements.canvasDrawingTracerSection.classList.add('hidden');
        elements.letterCanvas.classList.add('hidden'); // Hide canvas element directly
        elements.clearCanvasBtn.classList.add('hidden');
        elements.nextLetterBtn.classList.add('hidden');
        
        // Re-added score and stars display hiding
        elements.scoreDisplay.classList.add('hidden'); 
        elements.starsDisplay.classList.add('hidden');
    }

    function clearBoard() {
        elements.feedback.textContent = '';
        elements.blendText.textContent = '';
        elements.blendBox.innerHTML = '';
        elements.wordChoices.innerHTML = '';
        gameState.blended = '';
        
        gameState.userBuiltWord = [];
        gameState.usedLetterButtons = []; 
        elements.buildWordDisplay.textContent = ''; 
        elements.buildWordDisplay.classList.remove('incorrect-feedback'); 
        elements.letterPool.innerHTML = '';
        elements.feedback.textContent = '';
        
        elements.buildWordTargetFlashcard.classList.add('hidden'); 
        elements.buildWordTargetFlashcard.classList.remove('fade-in');
        elements.buildWordTargetFlashcard.textContent = '';

        elements.flashcardPhonemeDescription.textContent = ''; 
        
        // Clear Picture-Word Matching specific elements
        elements.pictureWordImage.classList.add('hidden');
        elements.pictureWordImage.src = '';
        elements.pictureWordChoices.innerHTML = '';

        // Clear Tricky Word Sorting specific elements
        elements.trickyZone.querySelector('.words-container').innerHTML = ''; // Clear words in container
        elements.notTrickyZone.querySelector('.words-container').innerHTML = ''; // Clear words in container
        elements.trickyWordPool.innerHTML = '';
        elements.trickySortFeedback.textContent = '';

        // Clear Canvas Drawing Tracer specific elements
        if (gameState.canvasCtx) {
            gameState.canvasCtx.clearRect(0, 0, elements.letterCanvas.width, elements.letterCanvas.height);
        }
        elements.prompt.textContent = '';
    }

    function goHome() {
      console.log("goHome function called."); // Debugging log
      elements.gameArea.classList.add('hidden');
      elements.gameComplete.classList.add('hidden');
      elements.flashcardPackSelection.classList.add('hidden');
      elements.homeBtn.classList.add('hidden');
      elements.menu.classList.remove('hidden');
      console.log("Menu visibility set to: ", !elements.menu.classList.contains('hidden')); // Debugging log
      clearBoard();
    }

    function startGame(mode) {
      console.log(`startGame called with mode: ${mode}`); // Debugging log
      gameState.mode = mode;
      // Re-added score and stars initialization
      gameState.score = 0; 
      gameState.stars = 0; 
      if (mode === 'words') {
          gameState.currentWords = [...satpinWordsList]; 
      }
      gameState.currentFlashcardIndex = 0;
      gameState.flashcardsCompletedCount = 0;
      gameState.packSelectionType = ''; 
      gameState.currentFlashcardSetDescription = ''; 

      elements.menu.classList.add('hidden');
      elements.gameComplete.classList.add('hidden');
      elements.homeBtn.classList.remove('hidden');
      elements.gameArea.classList.remove('hidden');
      console.log(`gameArea classList after removing hidden: ${elements.gameArea.classList}`); // Debugging log
      
      clearBoard();
      // Re-added updateScore and updateStars calls
      updateScore(); 
      updateStars(); 
      hideAllGameSpecificElements();

      if (mode === 'words') {
        setupBlendMode();
      } else if (mode === 'build') {
          setupBuildMode();
      } else if (mode === 'pictureWordMatch') { 
          setupPictureWordMatching();
      } else if (mode === 'trickyWordSort') { 
          setupTrickyWordSorting();
      } else if (mode === 'canvasDrawingTracer') {
          setupCanvasDrawingTracer();
      }
    }

    function showFlashcardPackSelection(packType) {
        console.log(`showFlashcardPackSelection called with packType: ${packType}`); // Debugging log
        gameState.mode = 'flashcards'; 
        gameState.packSelectionType = packType; 

        elements.menu.classList.add('hidden');
        elements.gameComplete.classList.add('hidden');
        elements.homeBtn.classList.remove('hidden');
        elements.gameArea.classList.remove('hidden');
        console.log(`gameArea classList after removing hidden in flashcard selection: ${elements.gameArea.classList}`); // Debugging log

        hideAllGameSpecificElements();
        elements.flashcardPackSelection.classList.remove('hidden');
        
        elements.packSelectionIntroText.textContent = `Choose a ${packType === 'letters' ? 'Phase 2 Sound' : 'Tricky Word'} Set:`;

        elements.packButtons.innerHTML = '';
        const sets = packType === 'letters' ? letterSets : trickyWordSets;
        
        let allItems = [];
        let allItemsName = '';
        if (packType === 'letters') {
            allItems = [...allPhase2Letters];
            allItemsName = 'All Sounds';
        } else { 
            allItems = Object.values(trickyWordSets).flatMap(set => set.words);
            allItemsName = 'All Tricky Words';
        }

        for (const setName in sets) {
            const setContent = sets[setName];
            const displayItems = Array.isArray(setContent) ? setContent : setContent.words;
            const button = document.createElement('button');
            button.className = 'menu-button';
            button.textContent = `${setName}: ${displayItems.join(', ')}`;
            button.addEventListener('click', () => startFlashcardPack(setName, packType)); 
            elements.packButtons.appendChild(button);
        }

        const allButton = document.createElement('button');
        allButton.className = 'menu-button';
        allButton.textContent = allItemsName;
        allButton.addEventListener('click', () => startFlashcardPack(allItemsName, packType));
        elements.packButtons.appendChild(allButton);
    }


    function startFlashcardPack(packName, packType) {
        elements.flashcardPackSelection.classList.add('hidden');
        elements.flashcardContainer.classList.remove('hidden');
        elements.flashcardActions.classList.remove('hidden');
        elements.flashcardProgress.classList.remove('hidden');

        let itemsForThisPack;
        gameState.currentFlashcardSetDescription = ''; 

        if (packType === 'letters') {
            if (packName === 'All Sounds') {
                itemsForThisPack = [...allPhase2Letters];
            } else {
                itemsForThisPack = [...letterSets[packName]];
            }
            elements.prompt.textContent = `What sound is this?`;
        } else { 
            if (packName === 'All Tricky Words') {
                itemsForThisPack = Object.values(trickyWordSets).flatMap(set => set.words);
                elements.prompt.textContent = `What is this tricky word?`;
            } else {
                itemsForThisPack = [...trickyWordSets[packName].words];
                elements.prompt.textContent = `What is this tricky word?`;
                gameState.currentFlashcardSetDescription = trickyWordSets[packName].description;
            }
        }
        
        gameState.flashcardMasterList = itemsForThisPack;
        gameState.currentFlashcardLetters = shuffleArray([...itemsForThisPack]);
        gameState.currentFlashcardIndex = 0;
        gameState.currentFlashcardSetName = packName;
        gameState.flashcardsCompletedCount = 0;
        elements.flashcardContainer.dataset.masteredUniqueLetters = ''; 

        displayFlashcard();
    }

    function displayFlashcard() {
        if (gameState.currentFlashcardLetters.length === 0) {
            endGame("You've mastered all the letters!"); // Corrected message
            return;
        }

        const currentItem = gameState.currentFlashcardLetters[gameState.currentFlashcardIndex];
        elements.flashcardLetter.textContent = currentItem;
        elements.flashcardLetter.classList.remove('hidden-content');
        
        if (gameState.packSelectionType === 'letters') {
            elements.flashcardPhonemeDescription.textContent = phonemeDetails[currentItem]?.description || '';
        } else { 
            elements.flashcardPhonemeDescription.textContent = gameState.currentFlashcardSetDescription || 'Try to remember this word!';
        }

        elements.flashcardProgress.textContent = `Mastered: ${gameState.flashcardsCompletedCount} of ${gameState.flashcardMasterList.length}`;
    }

    function processFlashcardResponseAndAdvance(assessment) {
        elements.flashcardContainer.classList.add('fade-out');

        setTimeout(() => {
            const currentItem = gameState.currentFlashcardLetters[gameState.currentFlashcardIndex];

            if (assessment === 'gotIt') {
                if (!elements.flashcardContainer.dataset.masteredUniqueLetters.includes(currentItem)) {
                    gameState.flashcardsCompletedCount++;
                    elements.flashcardContainer.dataset.masteredUniqueLetters += currentItem; 
                }
                gameState.currentFlashcardLetters.splice(gameState.currentFlashcardIndex, 1);
                
                if (gameState.currentFlashcardLetters.length > 0) {
                    if (gameState.currentFlashcardIndex >= gameState.currentFlashcardLetters.length) {
                        gameState.currentFlashcardIndex = 0; 
                    }
                } else {
                    gameState.currentFlashcardIndex = 0;
                }

            } else if (assessment === 'needPractice') {
                gameState.currentFlashcardLetters.push(currentItem);
                gameState.currentFlashcardIndex++;
                if (gameState.currentFlashcardIndex >= gameState.currentFlashcardLetters.length) {
                    gameState.currentFlashcardIndex = 0; 
                }
            }

            elements.flashcardContainer.classList.remove('fade-out');
            displayFlashcard();
        }, 300);
    }

    // --- BLEND WORDS MODE ---
    function setupBlendMode() {
      clearBoard();
      elements.prompt.innerHTML = 'Blend the sounds and click the correct word.<br>Collect 10 ‚≠ê to complete this activity!'; 
      // Re-added updateScore and updateStars calls
      updateScore(); 
      updateStars(); 
      elements.resetBtn.classList.remove('hidden');
      elements.wordChoices.classList.remove('hidden');
      elements.blendText.classList.remove('hidden');
      elements.blendBox.classList.add('horizontal');

      toggleBlendingControls(true); 

      if (gameState.currentWords.length === 0) {
        endGame("You've blended all the SATPIN words!"); 
        return;
      }

      const wordIndex = Math.floor(Math.random() * gameState.currentWords.length);
      const chosenWordObject = gameState.currentWords.splice(wordIndex, 1)[0];
      gameState.correctWord = chosenWordObject.word;
      gameState.correctEmoji = chosenWordObject.emoji;
      gameState.currentWord = chosenWordObject; 

      elements.blendBox.innerHTML = ''; 
      gameState.blended = '';
      elements.blendText.textContent = gameState.blended.split('').join(' ');

      gameState.correctWord.split('').forEach(l => {
        const letterButton = document.createElement('button');
        letterButton.className = 'letter';
        letterButton.textContent = l;
        letterButton.addEventListener('click', (event) => {
          gameState.blended += l;
          elements.blendText.textContent = gameState.blended.split('').join(' ');
          event.target.classList.add('blended-active');
          event.target.disabled = true; 
          setTimeout(() => {
              event.target.classList.remove('blended-active');
          }, 150);
        });
        elements.blendBox.appendChild(letterButton);
      });

      const distractors = satpinWordsList.filter(w => w.word !== gameState.correctWord);
      const shuffledDistractors = distractors.sort(() => 0.5 - Math.random());
      const options = [chosenWordObject, ...shuffledDistractors.slice(0, 2)];
      
      elements.wordChoices.innerHTML = '';

      options.sort(() => 0.5 - Math.random()).forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'word-choice';
        btn.innerHTML = `${opt.word} <span class="emoji">${opt.emoji}</span>`;
        btn.addEventListener('click', () => handleChoice(opt.word, btn));
        elements.wordChoices.appendChild(btn);
      });
    }
    
    function handleChoice(selection, chosenButton) {
      toggleBlendingControls(false); 

      if (selection === gameState.correctWord) {
        // Re-added score and stars increment
        gameState.score++;
        gameState.stars++; 
        updateScore();
        updateStars();
        elements.feedback.textContent = `üéâ Correct! ${gameState.correctEmoji}`; 
        chosenButton.classList.add('correct-feedback');
        
        // Re-added stars check
        if (gameState.stars >= 10) { 
            endGame("You earned 10 stars!");
            return;
        }
        

        setTimeout(() => {
          chosenButton.classList.remove('correct-feedback');
          setupBlendMode();
        }, 1200);

      } else {
        elements.feedback.textContent = '‚ùå Try again!';
        chosenButton.classList.add('incorrect-feedback');
        setTimeout(() => {
          chosenButton.classList.remove('incorrect-feedback');
          toggleBlendingControls(true); 
          const letterButtons = elements.blendBox.querySelectorAll('.letter');
          letterButtons.forEach(button => {
              button.disabled = false; 
          });
        }, 800);
      }
    }


    // --- BUILD A WORD MODE ---
    function setupBuildMode() {
      clearBoard();
      elements.prompt.innerHTML = 'Use the letters to build a SATPIN word (from Set 1 & 2 sounds)!<br>Collect 10 ‚≠ê to complete this activity!'; 
      
      // Re-added updateScore and updateStars calls
      updateScore(); 
      updateStars(); 

      elements.buildWordTargetFlashcard.classList.remove('hidden'); 
      elements.buildWordDisplay.classList.remove('hidden');
      elements.letterPool.classList.remove('hidden');
      elements.buildActionsContainer.classList.remove('hidden'); 
      
      elements.clearBuildBtn.disabled = false;
      elements.deleteBuildBtn.disabled = false; 
      elements.checkBuildBtn.disabled = false;
      elements.resetBtn.disabled = false; 

      elements.clearBuildBtn.classList.remove('hidden');
      elements.deleteBuildBtn.classList.remove('hidden'); 
      elements.checkBuildBtn.classList.remove('hidden');
      elements.resetBtn.classList.remove('hidden'); 

      if (gameState.availableBuildWords.length === 0 || gameState.mode !== 'build') { 
          const filteredWords = satpinWordsList.filter(wordObj => {
              const wordLetters = wordObj.word.split('');
              const allowedLetters = [...letterSets['Set 1'], ...letterSets['Set 2']];
              
              const tempAllowed = [...allowedLetters];
              let possible = true;
              for (const char of wordLetters) {
                  const idx = tempAllowed.indexOf(char);
                  if (idx > -1) {
                      tempAllowed.splice(idx, 1); 
                  } else {
                      possible = false; 
                      break;
                  }
              }
              return possible;
          });
          gameState.availableBuildWords = shuffleArray([...filteredWords]);
          gameState.mode = 'build'; 
      }

      if (gameState.availableBuildWords.length === 0) {
          endGame('You have built all the words from Set 1 & 2!');
          return;
      }

      const wordIndex = Math.floor(Math.random() * gameState.availableBuildWords.length);
      const chosenWordObject = gameState.availableBuildWords.splice(wordIndex, 1)[0];
      gameState.targetBuildWord = chosenWordObject.word;
      gameState.correctEmoji = chosenWordObject.emoji;
      
      elements.buildWordTargetFlashcard.textContent = gameState.targetBuildWord.toLowerCase(); 
      elements.buildWordTargetFlashcard.classList.remove('fade-in'); 
      void elements.buildWordTargetFlashcard.offsetWidth; 
      elements.buildWordTargetFlashcard.classList.add('fade-in'); 

      gameState.userBuiltWord = []; 
      gameState.usedLetterButtons = []; 
      gameState.buildLettersPool = shuffleArray([...masterBuildLettersPool]); 
      
      renderLetterPool();
      updateBuildWordDisplay();
    }

    function selectLetterForBuild(letter, buttonElement) {
        gameState.userBuiltWord.push(letter);
        gameState.usedLetterButtons.push(buttonElement); 
        updateBuildWordDisplay();

        buttonElement.disabled = true; 
        buttonElement.classList.add('selected'); 
        buttonElement.classList.add('blended-active'); 
        setTimeout(() => {
            buttonElement.classList.remove('blended-active');
        }, 150);
    }

    function deleteLastLetter() {
        if (gameState.userBuiltWord.length > 0) {
            gameState.userBuiltWord.pop(); 
            
            const lastUsedButton = gameState.usedLetterButtons.pop(); 
            if (lastUsedButton) {
                lastUsedButton.disabled = false;
                lastUsedButton.classList.remove('selected');
                lastUsedButton.classList.remove('blended-active'); 
            }
            updateBuildWordDisplay();
        }
    }


    function renderLetterPool() {
      elements.letterPool.innerHTML = '';
      const currentPoolRender = [...masterBuildLettersPool]; 

      currentPoolRender.forEach((letter, index) => {
          const letterBtn = document.createElement('button');
          letterBtn.className = 'letter';
          letterBtn.textContent = letter;
          letterBtn.dataset.letterValue = letter; 
          letterBtn.dataset.originalIndex = index; 
          letterBtn.addEventListener('click', () => selectLetterForBuild(letter, letterBtn));
          elements.letterPool.appendChild(letterBtn);
      });
    }

    function clearBuild() {
        gameState.userBuiltWord = [];
        gameState.usedLetterButtons.forEach(button => { 
            button.disabled = false;
            button.classList.remove('selected');
            button.classList.remove('blended-active');
        });
        gameState.usedLetterButtons = []; 
        updateBuildWordDisplay();
        elements.feedback.textContent = '';
        
    }

    function checkBuildWord() {
        if (gameState.userBuiltWord.join('') === gameState.targetBuildWord) {
            elements.feedback.textContent = `üéâ Correct! You built: ${gameState.targetBuildWord.toLowerCase()} ${gameState.correctEmoji}`; 
            
            // Re-added stars increment
            gameState.score++;
            gameState.stars++;
            updateScore();
            updateStars();

            elements.letterPool.querySelectorAll('.letter').forEach(btn => btn.setAttribute('disabled', 'true')); // Disable all letters
            elements.clearBuildBtn.disabled = true;
            elements.deleteBuildBtn.disabled = true; 
            elements.checkBuildBtn.disabled = true;

            // Re-added stars check
            if (gameState.stars >= 10) { 
                endGame("You earned 10 stars!");
                return;
            }
            

            setTimeout(() => {
                setupBuildMode(); 
            }, 1800); 
        } else {
            elements.feedback.textContent = '‚ùå Not quite! Try again.';
            elements.buildWordDisplay.classList.add('incorrect-feedback'); 
            setTimeout(() => {
                elements.buildWordDisplay.classList.remove('incorrect-feedback'); 
            }, 800);
        }
    }


    // --- NEW: PICTURE-WORD MATCHING MODE ---
    function setupPictureWordMatching() {
      clearBoard();
      gameState.mode = 'pictureWordMatch';
      elements.prompt.innerHTML = 'Match the picture with the correct word!';
      elements.pictureWordMatchingSection.classList.remove('hidden');
      elements.pictureWordImage.classList.remove('hidden');
      elements.pictureWordResetBtn.classList.remove('hidden');
      
      // Re-added updateScore and updateStars calls
      updateScore(); 
      updateStars(); 

      gameState.pictureWordMatchWords = shuffleArray([...satpinWordsList]);
      loadNextPictureWord();
    }

    function loadNextPictureWord() {
      if (gameState.pictureWordMatchWords.length === 0) {
          endGame("You've matched all the words!");
          return;
      }

      gameState.currentPictureWord = gameState.pictureWordMatchWords.shift();
      elements.pictureWordImage.src = gameState.currentPictureWord.image;
      elements.pictureWordImage.alt = gameState.currentPictureWord.word;

      elements.feedback.textContent = ''; // Clear feedback

      // Generate choices
      const correctWord = gameState.currentPictureWord;
      const distractors = satpinWordsList.filter(w => w.word !== correctWord.word);
      const shuffledDistractors = shuffleArray(distractors).slice(0, 2); // Get 2 random distractors
      const choices = shuffleArray([correctWord, ...shuffledDistractors]);

      elements.pictureWordChoices.innerHTML = '';
      choices.forEach(choice => {
          const btn = document.createElement('button');
          btn.className = 'word-choice';
          btn.textContent = choice.word;
          btn.dataset.word = choice.word;
          btn.addEventListener('click', () => handlePictureWordChoice(choice.word, btn));
          elements.pictureWordChoices.appendChild(btn);
      });
    }

    function handlePictureWordChoice(selectedWord, chosenButton) {
      // Disable all choice buttons to prevent multiple clicks
      Array.from(elements.pictureWordChoices.children).forEach(btn => btn.disabled = true);

      if (selectedWord === gameState.currentPictureWord.word) {
          elements.feedback.textContent = `üéâ Correct! ${gameState.currentPictureWord.emoji}`;
          chosenButton.classList.add('correct-feedback');
          // Re-added stars increment
          gameState.score++;
          gameState.stars++;
          updateScore();
          updateStars();

          // Re-added stars check
          if (gameState.stars >= 10) {
              endGame("You earned 10 stars!");
              return;
          }
          

          setTimeout(() => {
              chosenButton.classList.remove('correct-feedback');
              loadNextPictureWord();
          }, 1500);
      } else {
          elements.feedback.textContent = '‚ùå Try again!';
          chosenButton.classList.add('incorrect-feedback');
          // Find and highlight the correct answer briefly
          const correctButton = elements.pictureWordChoices.querySelector(`[data-word="${gameState.currentPictureWord.word}"]`);
          if (correctButton) {
              correctButton.classList.add('correct-feedback');
          }

          setTimeout(() => {
              chosenButton.classList.remove('incorrect-feedback');
              if (correctButton) {
                  correctButton.classList.remove('correct-feedback');
              }
              // Re-enable buttons if incorrect, so user can try again
              Array.from(elements.pictureWordChoices.children).forEach(btn => btn.disabled = false);
              elements.feedback.textContent = ''; // Clear feedback after showing it
          }, 1500);
      }
    }

    // --- NEW: TRICKY WORD SORTING GAME ---
    function setupTrickyWordSorting() {
        clearBoard();
        gameState.mode = 'trickyWordSort';
        elements.prompt.innerHTML = 'Drag "Tricky Words" to the left box and "Not Tricky Words" to the right!';
        elements.trickyWordSortingSection.classList.remove('hidden');
        elements.trickySortResetBtn.classList.remove('hidden');
        elements.trickySortCheckBtn.classList.remove('hidden'); // Ensure button is visible
        elements.newTrickySortResetBtn.classList.remove('hidden'); // Show new reset button
        elements.trickySortCheckBtn.disabled = true; // Explicitly disable at start


        // Re-added updateScore and updateStars calls
        updateScore();
        updateStars();

        // Select 3 tricky and 3 not tricky words
        const selectedTricky = shuffleArray([...trickyWordsData.tricky]).slice(0, 3);
        const selectedNotTricky = shuffleArray([...trickyWordsData.notTricky]).slice(0, 3);

        // Combine and shuffle for the pool
        const allWordsForRound = [
            ...selectedTricky.map(word => ({ word, type: 'tricky' })),
            ...selectedNotTricky.map(word => ({ word, type: 'notTricky' }))
        ];
        gameState.trickySortWords = shuffleArray(allWordsForRound);


        renderTrickyWordPool();
        renderSortZones(); // Initial render of empty zones
    }

    function renderTrickyWordPool() {
        elements.trickyWordPool.innerHTML = '';
        gameState.trickySortWords.forEach(wordObj => {
            const wordElement = document.createElement('div');
            wordElement.classList.add('sortable-word');
            wordElement.textContent = wordObj.word;
            wordElement.setAttribute('draggable', true);
            wordElement.dataset.word = wordObj.word;
            wordElement.dataset.type = wordObj.type;
            wordElement.addEventListener('dragstart', handleTrickyWordDragStart);
            elements.trickyWordPool.appendChild(wordElement);
        });
    }

    function renderSortZones() {
        // Clear existing content but keep headers
        elements.trickyZone.querySelector('.words-container').innerHTML = '';
        elements.notTrickyZone.querySelector('.words-container').innerHTML = '';

        // Re-attach drag listeners to zones (still on the main sort-zone)
        elements.trickyZone.addEventListener('dragover', handleTrickyWordDragOver);
        elements.trickyZone.addEventListener('dragleave', handleTrickyWordDragLeave);
        elements.trickyZone.addEventListener('drop', handleTrickyWordDrop);
        elements.notTrickyZone.addEventListener('dragover', handleTrickyWordDragOver);
        elements.notTrickyZone.addEventListener('dragleave', handleTrickyWordDragLeave);
        elements.notTrickyZone.addEventListener('drop', handleTrickyWordDrop);
    }

    function handleTrickyWordDragStart(e) {
        // Ensure the target is a sortable word and has dataset properties
        if (e.target && e.target.classList.contains('sortable-word') && e.target.dataset.word && e.target.dataset.type) {
            draggedTrickyWordElement = e.target; // Set global reference
            e.dataTransfer.setData('text/plain', e.target.dataset.word);
            e.dataTransfer.setData('text/word-type', e.target.dataset.type); // Store the type as well
            e.dataTransfer.effectAllowed = 'move';
        } else {
            e.preventDefault(); // Prevent dragging if it's not a valid sortable word
            draggedTrickyWordElement = null; // Ensure it's null if drag is invalid
        }
    }

    function handleTrickyWordDragOver(e) {
        e.preventDefault();
        e.target.closest('.sort-zone').classList.add('drag-over');
    }

    function handleTrickyWordDragLeave(e) {
        e.target.closest('.sort-zone').classList.remove('drag-over');
    }

    function handleTrickyWordDrop(e) {
        e.preventDefault();
        const dropZone = e.target.closest('.sort-zone');
        if (!dropZone) {
            return;
        }
        dropZone.classList.remove('drag-over');

        // Use the globally stored dragged element for its data and removal
        if (!draggedTrickyWordElement) {
            return;
        }

        const word = draggedTrickyWordElement.dataset.word;
        const wordType = draggedTrickyWordElement.dataset.type; 

        if (!word || !wordType) {
            return;
        }

        // Remove the original element from its previous parent
        if (draggedTrickyWordElement.parentNode) {
            draggedTrickyWordElement.parentNode.removeChild(draggedTrickyWordElement);
        }

        // Create a new element for the dropped word in the target zone
        const newWordElement = document.createElement('div');
        newWordElement.classList.add('sortable-word');
        newWordElement.textContent = word;
        newWordElement.setAttribute('draggable', true);
        newWordElement.dataset.word = word;
        newWordElement.dataset.type = wordType;
        newWordElement.addEventListener('dragstart', handleTrickyWordDragStart); // Re-attach dragstart listener
        
        // Append to the inner words-container
        dropZone.querySelector('.words-container').appendChild(newWordElement);

        elements.trickySortFeedback.textContent = ''; // Clear feedback on drag
        
        // Check if the word pool is empty after the drop and update prompt/button state
        if (elements.trickyWordPool.children.length === 0) {
            elements.prompt.textContent = 'All words sorted! Click "Check My Sort" to see how you did.';
            elements.trickySortCheckBtn.disabled = false; // Enable the button
        } else {
            elements.prompt.textContent = 'Drag "Tricky Words" to the left box and "Not Tricky Words" to the right!';
            elements.trickySortCheckBtn.disabled = true; // Disable if words remain
        }
        
    }

    function checkTrickyWordSort() {
        let allCorrect = true;
        // Query words from within the .words-container
        let wordsInTrickyZone = Array.from(elements.trickyZone.querySelector('.words-container').querySelectorAll('.sortable-word'));
        let wordsInNotTrickyZone = Array.from(elements.notTrickyZone.querySelector('.words-container').querySelectorAll('.sortable-word'));
        let incorrectWords = [];

        // Corrected logic: Check against the element's own dataset.type
        wordsInTrickyZone.forEach(wordEl => {
            if (wordEl.dataset.type !== 'tricky') { // Check the element's own type
                allCorrect = false;
                incorrectWords.push(wordEl);
            }
        });
        wordsInNotTrickyZone.forEach(wordEl => {
            if (wordEl.dataset.type !== 'notTricky') { // Check the element's own type
                allCorrect = false;
                incorrectWords.push(wordEl);
            }
        });
        
        // Check if any words are still in the pool (shouldn't be if button is enabled, but for robustness)
        if (elements.trickyWordPool.children.length > 0) {
            allCorrect = false;
        }

        // If there are incorrect words or words in the pool, move incorrect ones back
        if (!allCorrect) {
            elements.trickySortFeedback.textContent = '‚ùå Some words were moved back. Try again!';
            elements.trickySortFeedback.classList.remove('correct');
            elements.trickySortFeedback.classList.add('incorrect');

            // Move incorrect words back to the pool
            incorrectWords.forEach(wordEl => {
                wordEl.remove(); // Remove from current zone
                // Re-add to the pool
                const newWordElement = document.createElement('div');
                newWordElement.classList.add('sortable-word');
                newWordElement.textContent = wordEl.dataset.word;
                newWordElement.setAttribute('draggable', true);
                newWordElement.dataset.word = wordEl.dataset.word;
                newWordElement.dataset.type = wordEl.dataset.type; // Preserve original type
                newWordElement.addEventListener('dragstart', handleTrickyWordDragStart);
                elements.trickyWordPool.appendChild(newWordElement);
            });
            
            // Re-enable the check button, as words are back in the pool for another attempt
            elements.trickySortCheckBtn.disabled = false;
            elements.prompt.textContent = 'Drag "Tricky Words" to the left box and "Not Tricky Words" to the right!';
            

        } else { // All correct
            elements.trickySortFeedback.textContent = 'üéâ Great job! All words sorted correctly!';
            elements.trickySortFeedback.classList.remove('incorrect');
            elements.trickySortFeedback.classList.add('correct');
            // Re-added stars increment
            gameState.score++;
            gameState.stars++;
            updateScore();
            updateStars();

            // Re-added stars check
            if (gameState.stars >= 10) {
                endGame("You earned 10 stars!");
                return;
            }
            

            setTimeout(setupTrickyWordSorting, 2000); // Load new set of words after a delay
        }
    }


    function endGame(message) {
      elements.gameArea.classList.add('hidden');
      elements.gameComplete.classList.remove('hidden');
      elements.finalMessage.textContent = message;
      
      // Remove existing specific play again buttons to avoid duplicates
      let existingChooseAnotherPack = elements.gameComplete.querySelector('.choose-another-pack-btn');
      if (existingChooseAnotherPack) {
          existingChooseAnotherPack.remove();
      }
      let existingChooseAnotherGame = elements.gameComplete.querySelector('.choose-another-game-btn');
      if (existingChooseAnotherGame) {
          existingChooseAnotherGame.remove();
      }

      // Set playAgainBtn text and action based on the current game mode
      let playAgainText = 'Play Again';
      let playAgainAction = () => goHome(); // Default to home

      if (gameState.mode === 'words') {
          playAgainText = 'Play Blend SATPIN Words Again';
          playAgainAction = () => startGame('words');
      } else if (gameState.mode === 'build') {
          playAgainText = 'Play Build a Word Again';
          playAgainAction = () => startGame('build');
      } else if (gameState.mode === 'pictureWordMatch') {
          playAgainText = 'Play Picture-Word Match Again';
          playAgainAction = () => startGame('pictureWordMatch');
      } else if (gameState.mode === 'trickyWordSort') { // Specific for tricky word sort
          playAgainText = 'Play Tricky Word Sort Again';
          playAgainAction = () => startGame('trickyWordSort');
      } else if (gameState.mode === 'canvasDrawingTracer') {
          playAgainText = 'Play Trace Letters Again';
          playAgainAction = () => startGame('canvasDrawingTracer');
      } else if (gameState.mode === 'flashcards') {
          // For flashcards, it should go back to pack selection or home
          playAgainText = `Play ${gameState.currentFlashcardSetName || 'Flashcards'} Again`;
          playAgainAction = () => showFlashcardPackSelection(gameState.packSelectionType);
          if (!gameState.packSelectionType) { // Fallback if type not set
              playAgainAction = () => goHome();
          }
      }
      
      elements.playAgainBtn.textContent = playAgainText; 
      elements.playAgainBtn.onclick = playAgainAction;

      const chooseAnotherGameBtn = document.createElement('button');
      chooseAnotherGameBtn.className = 'play-again choose-another-game-btn';
      chooseAnotherGameBtn.textContent = 'Choose Another Game';
      chooseAnotherGameBtn.onclick = () => goHome();
      elements.gameComplete.appendChild(chooseAnotherGameBtn);
    }

    // --- CANVAS DRAWING TRACER FUNCTIONS (GLOBAL) ---
    function setupCanvasDrawingTracer() {
        clearBoard();
        gameState.mode = 'canvasDrawingTracer';
        elements.prompt.textContent = 'Trace the letter with your finger or mouse!';
        elements.canvasDrawingTracerSection.classList.remove('hidden');
        elements.letterCanvas.classList.remove('hidden'); // Ensure canvas is visible
        elements.clearCanvasBtn.classList.remove('hidden');
        elements.nextLetterBtn.classList.remove('hidden');

        // Re-added updateScore and updateStars calls
        updateScore();
        updateStars();

        // Initialize canvas context if not already done
        if (!gameState.canvasCtx) {
            gameState.canvasCtx = elements.letterCanvas.getContext('2d');
            addCanvasEventListeners();
        }
        
        // Initialize letters to trace list (reverted to text-based)
        const singleLetters = allPhase2Letters.filter(letter => letter.length === 1);
        gameState.lettersToTrace = shuffleArray(singleLetters);

        // Ensure font is loaded before attempting to draw
        document.fonts.ready.then(() => {
            // Use a small timeout to allow browser to render the canvas element after it becomes visible
            setTimeout(() => {
                resizeCanvas(); // Call resize after fonts are confirmed loaded and canvas is rendered
                // window.addEventListener('resize', resizeCanvas); // Moved to DOMContentLoaded
                loadLetterToTrace();
            }, 50); // Small delay
        }).catch(err => {
            console.error('Font loading failed:', err); // Debugging log
            // Fallback if font fails to load
            setTimeout(() => {
                resizeCanvas();
                // window.addEventListener('resize', resizeCanvas); // Moved to DOMContentLoaded
                loadLetterToTrace();
            }, 50);
        });
    }

    function resizeCanvas() {
        const canvas = elements.letterCanvas;
        // Get the actual rendered dimensions of the canvas element
        const displayWidth = canvas.offsetWidth;
        const displayHeight = canvas.offsetHeight;

        // Set the internal drawing buffer size to match the display size
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        
        console.log(`Canvas resized. Internal: ${canvas.width}x${canvas.height}, Display: ${displayWidth}x${displayHeight}`); // Debugging log
        // Redraw the faded letter after resize
        drawFadedLetter(gameState.currentTracingLetter);
    }

    function addCanvasEventListeners() {
        const canvas = elements.letterCanvas;
        const ctx = gameState.canvasCtx;

        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            startDrawing(e.touches[0]);
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            draw(e.touches[0]);
        }, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
    }

    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        // Calculate coordinates relative to the canvas's display size
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;

        // Scale coordinates from display pixels to internal canvas pixels
        // This is crucial if canvas.width/height (internal) differs from rect.width/height (display)
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const scaledX = x * scaleX;
        const scaledY = y * scaleY; 
        return { x: scaledX, y: scaledY };
    }

    function startDrawing(e) {
        gameState.isDrawing = true;
        const pos = getMousePos(elements.letterCanvas, e);
        gameState.lastX = pos.x;
        gameState.lastY = pos.y;
        gameState.hasDrawnOnCanvas = true; // Mark that drawing has started
        // Start a new path for each new drawing stroke
        gameState.canvasCtx.beginPath();
        gameState.canvasCtx.moveTo(gameState.lastX, gameState.lastY);
    }

    function draw(e) {
        if (!gameState.isDrawing) return;
        const ctx = gameState.canvasCtx;
        const pos = getMousePos(elements.letterCanvas, e);

        // Use quadraticCurveTo for smoother lines
        ctx.quadraticCurveTo(gameState.lastX, gameState.lastY, (gameState.lastX + pos.x) / 2, (gameState.lastY + pos.y) / 2);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-drawing-color');
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.stroke();

        gameState.lastX = pos.x;
        gameState.lastY = pos.y;
    }

    function stopDrawing() {
        gameState.isDrawing = false;
    }

    function loadLetterToTrace() {
        // Check if there are letters left in the queue
        if (gameState.lettersToTrace.length === 0) {
            endGame("You've traced all the letters!");
            // Re-initialize for next game
            const singleLetters = allPhase2Letters.filter(letter => letter.length === 1);
            gameState.lettersToTrace = shuffleArray(singleLetters);
            return;
        }
        
        // Get the next letter from the queue
        gameState.currentTracingLetter = gameState.lettersToTrace.shift();
        
        clearCanvasDrawing(); // Clear user drawing and redraw faded letter
        gameState.hasDrawnOnCanvas = false; // Reset drawing flag for new letter
        elements.feedback.textContent = ''; // Clear feedback
    }

    function drawFadedLetter(letter) {
        const ctx = gameState.canvasCtx;
        const canvas = elements.letterCanvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear everything first

        ctx.save(); // Save current context state
        ctx.globalAlpha = 0.7; 
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
        
        // Set font to 80% of canvas height for better fit
        const fontSize = canvas.height * 0.8; 
        const fontFamily = getComputedStyle(document.documentElement).getPropertyValue('--main-font');
        ctx.font = `${fontSize}px ${fontFamily}`; 
        
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(letter, canvas.width / 2, canvas.height / 2);
        ctx.restore(); // Restore context state (resets globalAlpha)
    }

    function clearCanvasDrawing() {
        const ctx = gameState.canvasCtx;
        const canvas = elements.letterCanvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawFadedLetter(gameState.currentTracingLetter); // Redraw the faded letter
        elements.feedback.textContent = '';
        gameState.hasDrawnOnCanvas = false; // Reset drawing flag
    }

    function nextTracingLetter() {
        if (gameState.hasDrawnOnCanvas) {
            elements.feedback.textContent = 'üéâ Great tracing!';
            elements.feedback.classList.remove('incorrect');
            elements.feedback.classList.add('correct');
            // Re-added stars increment
            gameState.score++;
            gameState.stars++;
            updateScore();
            updateStars();
            setTimeout(() => {
                loadLetterToTrace();
            }, 1000); // Short delay before next letter
        } else {
            elements.feedback.textContent = 'Please trace the letter first!';
            elements.feedback.classList.remove('correct');
            elements.feedback.classList.add('incorrect');
        }
    }


    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOMContentLoaded fired."); // Debugging log
      // --- DOM ELEMENTS (INITIALIZED ON DOMContentLoaded) ---
      elements = { // Assign to the globally declared elements object
        menu: document.getElementById('menu'),
        gameArea: document.getElementById('gameArea'),
        homeBtn: document.getElementById('homeBtn'),
        learnLettersBtn: document.getElementById('learnLettersBtn'),
        blendWordsBtn: document.getElementById('blendWordsBtn'),
        buildWordBtn: document.getElementById('buildWordBtn'),
        trickyWordsBtn: document.getElementById('trickyWordsBtn'), 
        pictureWordMatchBtn: document.getElementById('pictureWordMatchBtn'),
        trickyWordSortBtn: document.getElementById('trickyWordSortBtn'),
        canvasDrawingTracerBtn: document.getElementById('canvasDrawingTracerBtn'),
        // Re-added score and stars display elements
        scoreDisplay: document.getElementById('score'),
        starsDisplay: document.getElementById('stars'),
        prompt: document.getElementById('prompt'),
        
        flashcardPackSelection: document.getElementById('flashcardPackSelection'),
        packSelectionIntroText: document.getElementById('packSelectionIntroText'), 
        packButtons: document.getElementById('packButtons'),
        backToMainMenuBtn: document.getElementById('backToMainMenuBtn'),

        flashcardContainer: document.getElementById('flashcardContainer'),
        flashcardLetter: document.getElementById('flashcardLetter'),
        flashcardPhonemeDescription: document.getElementById('flashcardPhonemeDescription'),
        flashcardActions: document.getElementById('flashcardActions'),
        gotItBtn: document.getElementById('gotItBtn'),
        needPracticeBtn: document.getElementById('needPracticeBtn'),

        flashcardProgress: document.getElementById('flashcardProgress'),

        blendBox: document.getElementById('blendBox'),
        blendText: document.getElementById('blendText'),

        buildWordTargetFlashcard: document.getElementById('buildWordTargetFlashcard'), 

        buildWordDisplay: document.getElementById('buildWordDisplay'),
        letterPool: document.getElementById('letterPool'),
        buildActionsContainer: document.querySelector('.build-actions'), 
        clearBuildBtn: document.getElementById('clearBuildBtn'),
        deleteBuildBtn: document.getElementById('deleteBuildBtn'), 
        checkBuildBtn: document.getElementById('checkBuildBtn'),
        
        pictureWordMatchingSection: document.getElementById('pictureWordMatchingSection'),
        pictureWordImage: document.getElementById('pictureWordImage'),
        pictureWordChoices: document.getElementById('pictureWordChoices'),
        pictureWordResetBtn: document.getElementById('pictureWordResetBtn'),

        trickyWordSortingSection: document.getElementById('trickyWordSortingSection'),
        trickyZone: document.getElementById('trickyZone'),
        notTrickyZone: document.getElementById('notTrickyZone'),
        trickyWordPool: document.getElementById('trickyWordPool'),
        trickySortFeedback: document.getElementById('trickySortFeedback'),
        trickySortResetBtn: document.getElementById('trickySortResetBtn'),
        trickySortCheckBtn: document.getElementById('trickySortCheckBtn'),
        newTrickySortResetBtn: document.getElementById('newTrickySortResetBtn'), // New button reference

        canvasDrawingTracerSection: document.getElementById('canvasDrawingTracerSection'),
        letterCanvas: document.getElementById('letterCanvas'),
        clearCanvasBtn: document.getElementById('clearCanvasBtn'),
        nextLetterBtn: document.getElementById('nextLetterBtn'),

        wordChoices: document.getElementById('wordChoices'),
        resetBtn: document.getElementById('resetBtn'), 
        feedback: document.getElementById('feedback'),
        gameComplete: document.getElementById('gameComplete'),
        finalMessage: document.getElementById('finalMessage'),
        playAgainBtn: document.getElementById('playAgainBtn'),
      };

      // --- EVENT LISTENERS (ATTACHED ON DOMContentLoaded) ---
      elements.learnLettersBtn.addEventListener('click', () => { console.log('Learn Letters clicked'); showFlashcardPackSelection('letters'); });
      elements.blendWordsBtn.addEventListener('click', () => { console.log('Blend Words clicked'); startGame('words'); });
      elements.buildWordBtn.addEventListener('click', () => { console.log('Build Word clicked'); startGame('build'); });
      elements.trickyWordsBtn.addEventListener('click', () => { console.log('Tricky Words clicked'); showFlashcardPackSelection('trickyWords'); }); 
      elements.pictureWordMatchBtn.addEventListener('click', () => { console.log('Picture-Word Match clicked'); startGame('pictureWordMatch'); }); 
      elements.trickyWordSortBtn.addEventListener('click', () => { console.log('Tricky Word Sort clicked'); startGame('trickyWordSort'); }); 
      elements.canvasDrawingTracerBtn.addEventListener('click', () => { console.log('Trace Letters clicked'); startGame('canvasDrawingTracer'); });
      elements.homeBtn.addEventListener('click', goHome); 

      elements.resetBtn.addEventListener('click', () => {
        if (gameState.mode === 'words') {
          gameState.blended = '';
          elements.blendText.textContent = gameState.blended.split('').join(' ');
          const letterButtons = elements.blendBox.querySelectorAll('.letter');
          letterButtons.forEach(button => {
              button.classList.remove('blended-active');
              button.disabled = false; 
          });
          toggleBlendingControls(true); 
        } else if (gameState.mode === 'build') {
          setupBuildMode(); 
        }
      });

      elements.gotItBtn.addEventListener('click', () => processFlashcardResponseAndAdvance('gotIt'));
      elements.needPracticeBtn.addEventListener('click', () => processFlashcardResponseAndAdvance('needPractice'));

      elements.backToMainMenuBtn.addEventListener('click', goHome);

      elements.clearBuildBtn.addEventListener('click', clearBuild);
      elements.deleteBuildBtn.addEventListener('click', deleteLastLetter); 
      elements.checkBuildBtn.addEventListener('click', checkBuildWord);

      elements.pictureWordResetBtn.addEventListener('click', setupPictureWordMatching); 
      elements.trickySortResetBtn.addEventListener('click', setupTrickyWordSorting); 
      elements.trickySortCheckBtn.addEventListener('click', checkTrickyWordSort); 
      elements.newTrickySortResetBtn.addEventListener('click', setupTrickyWordSorting); // New listener for the new reset button

      elements.clearCanvasBtn.addEventListener('click', clearCanvasDrawing);
      elements.nextLetterBtn.addEventListener('click', nextTracingLetter);

      // Add a global dragend listener to reset draggedTrickyWordElement
      document.addEventListener('dragend', () => {
          draggedTrickyWordElement = null; // Clear the reference after drag operation
      });

      // Add window resize listener for canvas, only if canvas is active
      window.addEventListener('resize', () => {
          if (gameState.mode === 'canvasDrawingTracer' && elements.letterCanvas) {
              resizeCanvas();
          }
      });

      // Call goHome on initial load to ensure the main menu is visible
      goHome();
      
    });
  </script>
</body>
</html>
